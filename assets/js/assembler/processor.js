class AssemblyLine{constructor(e,t){this.element=t,this.instruction=new e(this.element.textContent),this.post_process=this.instruction.postProcess,this.bytes=[],this.error=null}generateBytes(e,t,s=null){if("instruction"==this.element.className||"directive"==this.element.className||""==this.element.className){if(this.instruction.findInstruction(),this.instruction.shouldPostProcess!=t)return;var n;n=this.instruction.shouldPostProcess?this.instruction.postProcessBytes(s,this.element):this.instruction.bytes;for(var r=[],i=0;i<n.length;i++)r="little"===e?r.concat(n[i].reverse()):r.concat(n[i]);this.bytes=r}}}class Processor{constructor(e){this.lines=[],this.parser=e,this.endian=null}processAssembly(e){this.lines.length=0,e.childNodes.forEach(e=>{var t=new AssemblyLine(this.parser,e);this.lines.push(t)})}generateBytes(){this.lines.forEach(e=>{try{e.generateBytes(this.endian,!1)}catch(t){e.error=t.message}}),this.lines.forEach(e=>{try{e.generateBytes(this.endian,!0,this)}catch(t){e.error=t.message}})}get byteArrays(){var e=[];return this.lines.forEach(t=>{t.bytes;e.push(t.bytes)}),e}get byteString(){var e="";return this.lines.forEach(t=>{for(var s=0;s<t.bytes.length;s++)e+="\\x"+t.bytes[s].toString(16)}),e}get errorLines(){var e=[];return this.lines.forEach(t=>{null!=t.error&&e.push(t)}),e}findLabel(e){var t=null;return this.lines.forEach(s=>{if("label"==s.element.className&&s.element.textContent.trim().replace(":","")==e)return void(t=s)}),t}lineIndex(e){return this.lines.findIndex(t=>t.element==e)}findByteDistance(e,t){var s=0,n=this.lineIndex(e),r=this.lineIndex(t);if(-1==n||-1==r)return-1;for(var i=Math.min(n,r),l=Math.max(n,r),h=i;h<=l;h++){var a=this.lines[h];"instruction"==a.element.className&&null==a.error?s+=4:"directive"==a.element.className&&(s+=a.bytes.length)}return i==n?s:-s}}